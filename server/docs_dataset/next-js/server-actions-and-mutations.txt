Updating Data

Menu
Using App Router
Features available in /app
Latest Version
16.1.1
Getting Started
Installation
Project Structure
Layouts and Pages
Linking and Navigating
Server and Client Components
Cache Components
Fetching Data
Updating Data
Caching and Revalidating
Error Handling
CSS
Image Optimization
Font Optimization
Metadata and OG images
Route Handlers
Proxy
Deploying
Upgrading
Guides
Analytics
Authentication
Backend for Frontend
Caching
CI Build Caching
Content Security Policy
CSS-in-JS
Custom Server
Data Security
Debugging
Draft Mode
Environment Variables
Forms
ISR
Instrumentation
Internationalization
JSON-LD
Lazy Loading
Development Environment
Next.js MCP Server
MDX
Memory Usage
Migrating
App Router
Create React App
Vite
Multi-tenant
Multi-zones
OpenTelemetry
Package Bundling
Prefetching
Production
PWAs
Redirecting
Sass
Scripts
Self-Hosting
SPAs
Static Exports
Tailwind CSS v3
Testing
Cypress
Jest
Playwright
Vitest
Third Party Libraries
Upgrading
Codemods
Version 14
Version 15
Version 16
Videos
API Reference
Directives
use cache
use cache: private
use cache: remote
use client
use server
Components
Font
Form Component
Image Component
Link Component
Script Component
File-system conventions
default.js
Dynamic Segments
error.js
forbidden.js
instrumentation.js
instrumentation-client.js
Intercepting Routes
layout.js
loading.js
mdx-components.js
not-found.js
page.js
Parallel Routes
proxy.js
public
route.js
Route Groups
Route Segment Config
src
template.js
unauthorized.js
Metadata Files
favicon, icon, and apple-icon
manifest.json
opengraph-image and twitter-image
robots.txt
sitemap.xml
Functions
after
cacheLife
cacheTag
connection
cookies
draftMode
fetch
forbidden
generateImageMetadata
generateMetadata
generateSitemaps
generateStaticParams
generateViewport
headers
ImageResponse
NextRequest
NextResponse
notFound
permanentRedirect
redirect
refresh
revalidatePath
revalidateTag
unauthorized
unstable_cache
unstable_noStore
unstable_rethrow
updateTag
useLinkStatus
useParams
usePathname
useReportWebVitals
useRouter
useSearchParams
useSelectedLayoutSegment
useSelectedLayoutSegments
userAgent
Configuration
next.config.js
experimental.adapterPath
allowedDevOrigins
appDir
assetPrefix
authInterrupts
basePath
browserDebugInfoInTerminal
cacheComponents
cacheHandlers
cacheLife
compress
crossOrigin
cssChunking
devIndicators
distDir
env
expireTime
exportPathMap
generateBuildId
generateEtags
headers
htmlLimitedBots
httpAgentOptions
images
cacheHandler
inlineCss
isolatedDevBuild
logging
mdxRs
onDemandEntries
optimizePackageImports
output
pageExtensions
poweredByHeader
productionBrowserSourceMaps
proxyClientMaxBodySize
reactCompiler
reactMaxHeadersLength
reactStrictMode
redirects
rewrites
sassOptions
serverActions
serverComponentsHmrCache
serverExternalPackages
staleTimes
staticGeneration*
taint
trailingSlash
transpilePackages
turbopack
turbopackFileSystemCache
typedRoutes
typescript
urlImports
useLightningcss
viewTransition
webpack
webVitalsAttribution
TypeScript
ESLint
CLI
create-next-app
next CLI
Edge Runtime
Turbopack
Getting Started
Installation
Project Structure
Images
Fonts
CSS
Deploying
Guides
Analytics
Authentication
Babel
CI Build Caching
Content Security Policy
CSS-in-JS
Custom Server
Debugging
Draft Mode
Environment Variables
Forms
ISR
Instrumentation
Internationalization
Lazy Loading
MDX
Migrating
App Router
Create React App
Vite
Multi-Zones
OpenTelemetry
Package Bundling
PostCSS
Preview Mode
Production
Redirecting
Sass
Scripts
Self-Hosting
Static Exports
Tailwind CSS
Testing
Cypress
Jest
Playwright
Vitest
Third Party Libraries
Upgrading
Codemods
Version 10
Version 11
Version 12
Version 13
Version 14
Version 9
Building Your Application
Routing
Pages and Layouts
Dynamic Routes
Linking and Navigating
Custom App
Custom Document
API Routes
Custom Errors
Rendering
Server-side Rendering (SSR)
Static Site Generation (SSG)
Automatic Static Optimization
Client-side Rendering (CSR)
Data Fetching
getStaticProps
getStaticPaths
Forms and Mutations
getServerSideProps
Client-side Fetching
Configuring
Error Handling
API Reference
Components
Font
Form
Head
Image
Image (Legacy)
Link
Script
File-system conventions
instrumentation.js
Proxy
public
src Directory
Functions
getInitialProps
getServerSideProps
getStaticPaths
getStaticProps
NextRequest
NextResponse
useReportWebVitals
useRouter
userAgent
Configuration
next.config.js Options
experimental.adapterPath
allowedDevOrigins
assetPrefix
basePath
bundlePagesRouterDependencies
compress
crossOrigin
devIndicators
distDir
env
exportPathMap
generateBuildId
generateEtags
headers
httpAgentOptions
images
isolatedDevBuild
onDemandEntries
optimizePackageImports
output
pageExtensions
poweredByHeader
productionBrowserSourceMaps
experimental.proxyClientMaxBodySize
reactStrictMode
redirects
rewrites
serverExternalPackages
trailingSlash
transpilePackages
turbopack
typescript
urlImports
useLightningcss
webpack
webVitalsAttribution
TypeScript
ESLint
CLI
create-next-app CLI
next CLI
Edge Runtime
Turbopack
Architecture
Accessibility
Fast Refresh
Next.js Compiler
Supported Browsers
Community
Contribution Guide
Rspack
On this page
What are Server Functions?
Creating Server Functions
Server Components
Client Components
Passing actions as props
Invoking Server Functions
Forms
Event Handlers
Examples
Showing a pending state
Refreshing
Revalidating
Redirecting
Cookies
useEffect
API Reference
Edit this page on GitHub
Scroll to top
App Router
Getting Started
Updating Data
Copy page
Updating Data
Last updated
November 5, 2025
You can update data in Next.js using React's
Server Functions
. This page will go through how you can
create
and
invoke
Server Functions.
What are Server Functions?
A
Server Function
is an asynchronous function that runs on the server. They can be called from the client through a network request, which is why they must be asynchronous.
In an
action
or mutation context, they are also called
Server Actions
.
By convention, a Server Action is an async function used with
startTransition
. This happens automatically when the function is:
Passed to a
<form>
using the
action
prop.
Passed to a
<button>
using the
formAction
prop.
In Next.js, Server Actions integrate with the framework's
caching
architecture. When an action is invoked, Next.js can return both the updated UI and new data in a single server roundtrip.
Behind the scenes, actions use the
POST
method, and only this HTTP method can invoke them.
Creating Server Functions
A Server Function can be defined by using the
use server
directive. You can place the directive at the top of an
asynchronous
function to mark the function as a Server Function, or at the top of a separate file to mark all exports of that file.
app/lib/actions.ts
TypeScript
JavaScript
TypeScript
export
async
function
createPost
(formData
:
FormData
) {
'use server'
const
title
=
formData
.get
(
'title'
)
const
content
=
formData
.get
(
'content'
)
// Update data
// Revalidate cache
}
export
async
function
deletePost
(formData
:
FormData
) {
'use server'
const
id
=
formData
.get
(
'id'
)
// Update data
// Revalidate cache
}
Server Components
Server Functions can be inlined in Server Components by adding the
"use server"
directive to the top of the function body:
app/page.tsx
TypeScript
JavaScript
TypeScript
export
default
function
Page
() {
// Server Action
async
function
createPost
(formData
:
FormData
) {
'use server'
// ...
}
return
<></>
}
Good to know:
Server Components support progressive enhancement by default, meaning forms that call Server Actions will be submitted even if JavaScript hasn't loaded yet or is disabled.
Client Components
It's not possible to define Server Functions in Client Components. However, you can invoke them in Client Components by importing them from a file that has the
"use server"
directive at the top of it:
app/actions.ts
TypeScript
JavaScript
TypeScript
'use server'
export
async
function
createPost
() {}
app/ui/button.tsx
TypeScript
JavaScript
TypeScript
'use client'
import
{ createPost }
from
'@/app/actions'
export
function
Button
() {
return
<
button
formAction
=
{createPost}>Create</
button
>
}
Good to know:
In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, and will be prioritized for hydration. After hydration, the browser does not refresh on form submission.
Passing actions as props
You can also pass an action to a Client Component as a prop:
<
ClientComponent
updateItemAction
=
{updateItem} />
app/client-component.tsx
TypeScript
JavaScript
TypeScript
'use client'
export
default
function
ClientComponent
({
updateItemAction
,
}
:
{
updateItemAction
:
(formData
:
FormData
)
=>
void
}) {
return
<
form
action
=
{updateItemAction}>{
/* ... */
}</
form
>
}
Invoking Server Functions
There are two main ways you can invoke a Server Function:
Forms
in Server and Client Components
Event Handlers
and
useEffect
in Client Components
Good to know:
Server Functions are designed for server-side mutations. The client currently dispatches and awaits them one at a time. This is an implementation detail and may change. If you need parallel data fetching, use
data fetching
in Server Components, or perform parallel work inside a single Server Function or
Route Handler
.
Forms
React extends the HTML
<form>
element to allow a Server Function to be invoked with the HTML
action
prop.
When invoked in a form, the function automatically receives the
FormData
object. You can extract the data using the native
FormData
methods
:
app/ui/form.tsx
TypeScript
JavaScript
TypeScript
import
{ createPost }
from
'@/app/actions'
export
function
Form
() {
return
(
<
form
action
=
{createPost}>
<
input
type
=
"text"
name
=
"title"
/>
<
input
type
=
"text"
name
=
"content"
/>
<
button
type
=
"submit"
>Create</
button
>
</
form
>
)
}
app/actions.ts
TypeScript
JavaScript
TypeScript
'use server'
export
async
function
createPost
(formData
:
FormData
) {
const
title
=
formData
.get
(
'title'
)
const
content
=
formData
.get
(
'content'
)
// Update data
// Revalidate cache
}
Event Handlers
You can invoke a Server Function in a Client Component by using event handlers such as
onClick
.
app/like-button.tsx
TypeScript
JavaScript
TypeScript
'use client'
import
{ incrementLike }
from
'./actions'
import
{ useState }
from
'react'
export
default
function
LikeButton
({ initialLikes }
:
{ initialLikes
:
number
}) {
const
[
likes
,
setLikes
]
=
useState
(initialLikes)
return
(
<>
<
p
>Total Likes: {likes}</
p
>
<
button
onClick
=
{
async
()
=>
{
const
updatedLikes
=
await
incrementLike
()
setLikes
(updatedLikes)
}}
>
Like
</
button
>
</>
)
}
Examples
Showing a pending state
While executing a Server Function, you can show a loading indicator with React's
useActionState
hook. This hook returns a
pending
boolean:
app/ui/button.tsx
TypeScript
JavaScript
TypeScript
'use client'
import
{ useActionState
,
startTransition }
from
'react'
import
{ createPost }
from
'@/app/actions'
import
{ LoadingSpinner }
from
'@/app/
ui
/loading-spinner'
export
function
Button
() {
const
[
state
,
action
,
pending
]
=
useActionState
(createPost
,
false
)
return
(
<
button
onClick
=
{()
=>
startTransition
(action)}>
{pending
?
<
LoadingSpinner
/>
:
'Create Post'
}
</
button
>
)
}
Refreshing
After a mutation, you may want to refresh the current page to show the latest data. You can do this by calling
refresh
from
next/cache
in a Server Action:
app/lib/actions.ts
TypeScript
JavaScript
TypeScript
'use server'
import
{ refresh }
from
'next/cache'
export
async
function
updatePost
(formData
:
FormData
) {
// Update data
// ...
refresh
()
}
This refreshes the client router, ensuring the UI reflects the latest state. The
refresh()
function does not revalidate tagged data. To revalidate tagged data, use
updateTag
or
revalidateTag
instead.
Revalidating
After performing an update, you can revalidate the Next.js cache and show the updated data by calling
revalidatePath
or
revalidateTag
within the Server Function:
app/lib/actions.ts
TypeScript
JavaScript
TypeScript
import
{ revalidatePath }
from
'next/cache'
export
async
function
createPost
(formData
:
FormData
) {
'use server'
// Update data
// ...
revalidatePath
(
'/posts'
)
}
Redirecting
You may want to redirect the user to a different page after performing an update. You can do this by calling
redirect
within the Server Function.
app/lib/actions.ts
TypeScript
JavaScript
TypeScript
'use server'
import
{ revalidatePath }
from
'next/cache'
import
{ redirect }
from
'next/navigation'
export
async
function
createPost
(formData
:
FormData
) {
// Update data
// ...
revalidatePath
(
'/posts'
)
redirect
(
'/posts'
)
}
Calling
redirect
throws
a framework handled control-flow exception. Any code after it won't execute. If you need fresh data, call
revalidatePath
or
revalidateTag
beforehand.
Cookies
You can
get
,
set
, and
delete
cookies inside a Server Action using the
cookies
API.
When you
set or delete
a cookie in a Server Action, Next.js re-renders the current page and its layouts on the server so the
UI reflects the new cookie value
.
Good to know
: The server update applies to the current React tree, re-rendering, mounting, or unmounting components, as needed. Client state is preserved for re-rendered components, and effects re-run if their dependencies changed.
app/actions.ts
TypeScript
JavaScript
TypeScript
'use server'
import
{ cookies }
from
'next/headers'
export
async
function
exampleAction
() {
const
cookieStore
=
await
cookies
()
// Get cookie
cookieStore
.get
(
'name'
)?.value
// Set cookie
cookieStore
.set
(
'name'
,
'Delba'
)
// Delete cookie
cookieStore
.delete
(
'name'
)
}
useEffect
You can use the React
useEffect
hook to invoke a Server Action when the component mounts or a dependency changes. This is useful for mutations that depend on global events or need to be triggered automatically. For example,
onKeyDown
for app shortcuts, an intersection observer hook for infinite scrolling, or when the component mounts to update a view count:
app/view-count.tsx
TypeScript
JavaScript
TypeScript
'use client'
import
{ incrementViews }
from
'./actions'
import
{ useState
,
useEffect
,
useTransition }
from
'react'
export
default
function
ViewCount
({ initialViews }
:
{ initialViews
:
number
}) {
const
[
views
,
setViews
]
=
useState
(initialViews)
const
[
isPending
,
startTransition
]
=
useTransition
()
useEffect
(()
=>
{
startTransition
(
async
()
=>
{
const
updatedViews
=
await
incrementViews
()
setViews
(updatedViews)
})
}
,
[])
// You can use `isPending` to give users feedback
return
<
p
>Total Views: {views}</
p
>
}
API Reference
Learn more about the features mentioned in this page by reading the API Reference.
revalidatePath
API Reference for the revalidatePath function.
revalidateTag
API Reference for the revalidateTag function.
redirect
API Reference for the redirect function.
Previous
Fetching Data
Next
Caching and Revalidating
Was this helpful?
supported.
Send